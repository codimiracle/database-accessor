package com.codimiracle.database.accessor;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * A implementation of DatabaseAccessor. {@code JDBCDatabaseAccessor} enclosed
 * JDBC connection, you can focus on what you want to do and what you need.
 * </p>
 * 
 * @author Codimiracle
 * @since 1.0
 */
public class JDBCDatabaseAccessor implements DatabaseAccessor {
	private JDBCConfig config;
	private Connection connection;

	/* manage {@code PreparedStatement} and {@code Statement}. */
	private Map<String, PreparedStatement> preparedStatementCache = new HashMap<>();
	private Statement statementCache = null;
	/* manage {@code ResultSet}. */
	private List<ResultSet> resultSets = new ArrayList<>();
	/* flag that indicates this accessor is closed. */
	private boolean close = false;

	/**
	 * get the config of database connection by jdbc.
	 * 
	 * @return
	 */
	public JDBCConfig getConfig() {
		return new JDBCConfig(config);
	}

	/**
	 * Create a {@code DatabaseAccessor} by {@code JDBCConfig}
	 * 
	 * @param config
	 * @throws DatabaseAccessorException
	 */
	public JDBCDatabaseAccessor(JDBCConfig config) throws DatabaseAccessorException {
		this.config = config;
		init();
	}

	/**
	 * Init statement.
	 * 
	 * @throws Exception
	 */
	private void createStatement() throws Exception {
		if (statementCache == null) {
			statementCache = connection.createStatement();
		}
	}

	@Override
	public boolean execute(String sql) throws DatabaseAccessorException {
		try {
			createStatement();
			return statementCache.execute(sql);
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	public ResultSet query(String sql) throws DatabaseAccessorException {
		;
		try {
			createStatement();
			return statementCache.executeQuery(sql);
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	public ResultSet query(String sql, Object[] args) throws DatabaseAccessorException {
		
		try {
			PreparedStatement preparedStatement = preparedStatement(sql, Statement.NO_GENERATED_KEYS, args);
			return preparedStatement.executeQuery();
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	private void init() throws DatabaseAccessorException {
		try {
			// load driver class.
			Class.forName(config.getDriverClass());
			connection = DriverManager.getConnection(config.getUrl(), config.getUser(), config.getPassword());
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	@Override
	public void close() throws IOException {
		if (close) {
			DatabaseAccessorException.throwFrom("the database accessor is closed!");
		}
		close = true;
		try {
			for (ResultSet resultSet : resultSets) {
				resultSet.close();
			}
			for (PreparedStatement preparedStatement : preparedStatementCache.values()) {
				preparedStatement.close();
			}
			if (statementCache != null)
				statementCache.close();
			if (connection != null)
				connection.close();
		} catch (Exception e) {
			// ignore
		}
	}

	@Override
	public int update(String sql) throws DatabaseAccessorException {
		runningSQLCheck(sql, "update");
		try {
			createStatement();
			return statementCache.executeUpdate(sql);
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	private PreparedStatement preparedStatement(String sql, int autoGeneratedKeys, Object[] args) throws SQLException {
		PreparedStatement preparedStatement = preparedStatementCache.get(sql);
		if (preparedStatement == null) {
			preparedStatement = connection.prepareStatement(sql, autoGeneratedKeys);
			preparedStatementCache.put(sql, preparedStatement);
		}
		for (int i = 0; i < args.length; i++) {
			preparedStatement.setObject(i + 1, args[i]);
		}
		return preparedStatement;
	}

	@Override
	public int update(String sql, Object[] args) throws DatabaseAccessorException {
		runningSQLCheck(sql, "update");
		try {
			PreparedStatement preparedStatement = preparedStatement(sql, Statement.NO_GENERATED_KEYS, args);
			return preparedStatement.executeUpdate();
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	private boolean isSQLVerbose(String sql, String verbose) {
		if (sql != null) {
			String trimedSQL = sql.trim();
			return trimedSQL.length() > verbose.length() && trimedSQL.toLowerCase().startsWith(verbose);
		}
		return false;
	}

	@Override
	public int insert(String sql) throws DatabaseAccessorException {
		runningSQLCheck(sql, "insert");
		try {
			createStatement();
			return statementCache.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	@Override
	public int insert(String sql, Object[] args) throws DatabaseAccessorException {
		runningSQLCheck(sql, "insert");
		try {
			PreparedStatement preparedStatement = preparedStatement(sql, Statement.RETURN_GENERATED_KEYS, args);
			return preparedStatement.executeUpdate();
		} catch (Exception e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	private void runningSQLCheck(String sql, String verbose) throws DatabaseAccessorException {
		if (isSQLVerbose(sql, verbose)) {
			throw DatabaseAccessorException
					.throwFrom("You must execute DML(" + verbose + ") statement but [" + sql + "] given.");
		}
	}

	@Override
	public int delete(String sql) throws DatabaseAccessorException {
		runningSQLCheck(sql, "delete");
		try {
			return statementCache.executeUpdate(sql);
		} catch (SQLException e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}

	@Override
	public int delete(String sql, Object[] args) throws DatabaseAccessorException {
		runningSQLCheck(sql, "delete");
		try {
			PreparedStatement preparedStatement = preparedStatement(sql, Statement.NO_GENERATED_KEYS, args);
			return preparedStatement.executeUpdate();
		} catch (SQLException e) {
			throw DatabaseAccessorException.throwFrom(e);
		} finally {
			// don't close the resource.
		}
	}
}
